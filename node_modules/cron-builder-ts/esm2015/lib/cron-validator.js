import { MEASURE_OF_TIME_MAP } from './types';
import { keys } from './utils';
export class CronValidator {
    /**
     * validates a given cron expression (object) for length, then calls validateValue on each value
     * @param {!{
     *  minute: Array.string,
     *  hour: Array.string,
     *  dayOfTheMonth: Array.string,
     *  month: Array.string,
     *  dayOfTheWeek: Array.string,
     * }} expression - rich object containing the state of the cron expression
     * @throws {Error} if expression contains more than 5 keys
     */
    static validateExpression(expression) {
        // don't care if it's less than 5, we'll just set those to the default '*'
        if (keys(expression).length > MEASURE_OF_TIME_MAP.length) {
            throw new Error(`Invalid cron expression; limited to ${MEASURE_OF_TIME_MAP.length} values.`);
        }
        keys(expression).forEach((key) => {
            expression[key].forEach((value) => {
                CronValidator.validateValue(key, value);
            });
        });
    }
    /**
     * validates a given cron expression (string) for length, then calls validateValue on each value
     * @param {!String} expression - an optionally empty string containing at most 5 space delimited expressions.
     * @throws {Error} if the string contains more than 5 space delimited parts.
     */
    static validateString(expression) {
        const splitExpression = expression.split(' ');
        if (splitExpression.length > MEASURE_OF_TIME_MAP.length) {
            throw new Error(`Invalid cron expression; limited to ${MEASURE_OF_TIME_MAP.length} values.`);
        }
        for (let i = 0; i < splitExpression.length; i += 1) {
            CronValidator.validateValue(MEASURE_OF_TIME_MAP[i], splitExpression[i]);
        }
    }
    /**
     * validates any given measureOfTime and corresponding value
     * @param {!String} measureOfTime - as expected
     * @param {!String} value - the cron-ish interval specifier
     * @throws {Error} if measureOfTime is bogus
     * @throws {Error} if value contains an unsupported character
     */
    static validateValue(measureOfTime, value) {
        const validatorObj = {
            minute: { min: 0, max: 59 },
            hour: { min: 0, max: 23 },
            dayOfTheMonth: { min: 1, max: 31 },
            month: { min: 1, max: 12 },
            dayOfTheWeek: { min: 0, max: 7 }
        };
        const validChars = /^[0-9*-]/;
        if (!validatorObj[measureOfTime]) {
            throw new Error(`Invalid measureOfTime; Valid options are: ${MEASURE_OF_TIME_MAP.join(', ')}`);
        }
        if (!validChars.test(value)) {
            throw new Error('Invalid value; Only numbers 0-9, "-", and "*" chars are allowed');
        }
        if (value === '*') {
            return;
        }
        // check to see if value is within range if value is not '*'
        if (value.indexOf('-') >= 0) {
            // value is a range and must be split into high and low
            const rangeArray = value
                .split('-')
                .map((range) => parseInt(range, 10))
                .filter((range) => isNaN(range) === false);
            const [rangeMin, rangeMax] = rangeArray;
            if (typeof rangeMin !== "number" || rangeMin < validatorObj[measureOfTime].min) {
                throw new Error(`Invalid value; bottom of range is not valid for \\"${measureOfTime}\\". Limit is ${validatorObj[measureOfTime].min}.`);
            }
            if (typeof rangeMax !== "number" || rangeMax > validatorObj[measureOfTime].max) {
                throw new Error(`Invalid value; top of range is not valid for \\"${measureOfTime}\\". Limit is ${validatorObj[measureOfTime].max}.`);
            }
        }
        else {
            if (parseInt(value) < validatorObj[measureOfTime].min) {
                throw new Error(`Invalid value; given value is not valid for \\"${measureOfTime}\\". Minimum value is \\"${validatorObj[measureOfTime].min}\\".`);
            }
            if (parseInt(value) > validatorObj[measureOfTime].max) {
                throw new Error(`Invalid value; given value is not valid for \\"${measureOfTime}\\". Maximum value is \\"${validatorObj[measureOfTime].max}\\".`);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3Jvbi12YWxpZGF0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jcm9uLWJ1aWxkZXItdHMvIiwic291cmNlcyI6WyJsaWIvY3Jvbi12YWxpZGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFjLG1CQUFtQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQzFELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFL0IsTUFBTSxPQUFPLGFBQWE7SUFDeEI7Ozs7Ozs7Ozs7T0FVRztJQUNJLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxVQUFzQjtRQUNyRCwwRUFBMEU7UUFDMUUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxHQUFHLG1CQUFtQixDQUFDLE1BQU0sRUFBRTtZQUN4RCxNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxtQkFBbUIsQ0FBQyxNQUFNLFVBQVUsQ0FBQyxDQUFDO1NBQzlGO1FBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQy9CLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDaEMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDMUMsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLGNBQWMsQ0FBQyxVQUFrQjtRQUM3QyxNQUFNLGVBQWUsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTlDLElBQUksZUFBZSxDQUFDLE1BQU0sR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUU7WUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsbUJBQW1CLENBQUMsTUFBTSxVQUFVLENBQUMsQ0FBQztTQUM5RjtRQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDbEQsYUFBYSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN6RTtJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQUMsYUFBYSxDQUFDLGFBQStCLEVBQUUsS0FBYTtRQUN4RSxNQUFNLFlBQVksR0FBRztZQUNuQixNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUU7WUFDM0IsSUFBSSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFO1lBQ3pCLGFBQWEsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRTtZQUNsQyxLQUFLLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUU7WUFDMUIsWUFBWSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFO1NBQ2pDLENBQUM7UUFFRixNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFFOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ2hHO1FBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxpRUFBaUUsQ0FBQyxDQUFDO1NBQ3BGO1FBRUQsSUFBSSxLQUFLLEtBQUssR0FBRyxFQUFFO1lBQ2pCLE9BQU87U0FDUjtRQUVELDREQUE0RDtRQUM1RCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzNCLHVEQUF1RDtZQUN2RCxNQUFNLFVBQVUsR0FBc0MsS0FBSztpQkFDeEQsS0FBSyxDQUFDLEdBQUcsQ0FBQztpQkFDVixHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7aUJBQ25DLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDO1lBRTdDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLEdBQUcsVUFBVSxDQUFDO1lBRXhDLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxJQUFJLFFBQVEsR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxFQUFFO2dCQUM5RSxNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxhQUFhLGlCQUFpQixZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQzthQUN6STtZQUVELElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxJQUFJLFFBQVEsR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxFQUFFO2dCQUM5RSxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxhQUFhLGlCQUFpQixZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQzthQUN0STtTQUNGO2FBQU07WUFDTCxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxFQUFFO2dCQUNyRCxNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxhQUFhLDRCQUE0QixZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQzthQUNuSjtZQUVELElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQyxHQUFHLEVBQUU7Z0JBQ3JELE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELGFBQWEsNEJBQTRCLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO2FBQ25KO1NBQ0Y7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHByZXNzaW9uLCBNRUFTVVJFX09GX1RJTUVfTUFQIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IGtleXMgfSBmcm9tICcuL3V0aWxzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBDcm9uVmFsaWRhdG9yIHtcclxuICAvKipcclxuICAgKiB2YWxpZGF0ZXMgYSBnaXZlbiBjcm9uIGV4cHJlc3Npb24gKG9iamVjdCkgZm9yIGxlbmd0aCwgdGhlbiBjYWxscyB2YWxpZGF0ZVZhbHVlIG9uIGVhY2ggdmFsdWVcclxuICAgKiBAcGFyYW0geyF7XHJcbiAgICogIG1pbnV0ZTogQXJyYXkuc3RyaW5nLFxyXG4gICAqICBob3VyOiBBcnJheS5zdHJpbmcsXHJcbiAgICogIGRheU9mVGhlTW9udGg6IEFycmF5LnN0cmluZyxcclxuICAgKiAgbW9udGg6IEFycmF5LnN0cmluZyxcclxuICAgKiAgZGF5T2ZUaGVXZWVrOiBBcnJheS5zdHJpbmcsXHJcbiAgICogfX0gZXhwcmVzc2lvbiAtIHJpY2ggb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0YXRlIG9mIHRoZSBjcm9uIGV4cHJlc3Npb25cclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgZXhwcmVzc2lvbiBjb250YWlucyBtb3JlIHRoYW4gNSBrZXlzXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyB2YWxpZGF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbjogRXhwcmVzc2lvbik6IHZvaWQge1xyXG4gICAgLy8gZG9uJ3QgY2FyZSBpZiBpdCdzIGxlc3MgdGhhbiA1LCB3ZSdsbCBqdXN0IHNldCB0aG9zZSB0byB0aGUgZGVmYXVsdCAnKidcclxuICAgIGlmIChrZXlzKGV4cHJlc3Npb24pLmxlbmd0aCA+IE1FQVNVUkVfT0ZfVElNRV9NQVAubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjcm9uIGV4cHJlc3Npb247IGxpbWl0ZWQgdG8gJHtNRUFTVVJFX09GX1RJTUVfTUFQLmxlbmd0aH0gdmFsdWVzLmApO1xyXG4gICAgfVxyXG5cclxuICAgIGtleXMoZXhwcmVzc2lvbikuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgIGV4cHJlc3Npb25ba2V5XS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIENyb25WYWxpZGF0b3IudmFsaWRhdGVWYWx1ZShrZXksIHZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHZhbGlkYXRlcyBhIGdpdmVuIGNyb24gZXhwcmVzc2lvbiAoc3RyaW5nKSBmb3IgbGVuZ3RoLCB0aGVuIGNhbGxzIHZhbGlkYXRlVmFsdWUgb24gZWFjaCB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7IVN0cmluZ30gZXhwcmVzc2lvbiAtIGFuIG9wdGlvbmFsbHkgZW1wdHkgc3RyaW5nIGNvbnRhaW5pbmcgYXQgbW9zdCA1IHNwYWNlIGRlbGltaXRlZCBleHByZXNzaW9ucy5cclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHN0cmluZyBjb250YWlucyBtb3JlIHRoYW4gNSBzcGFjZSBkZWxpbWl0ZWQgcGFydHMuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyB2YWxpZGF0ZVN0cmluZyhleHByZXNzaW9uOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnN0IHNwbGl0RXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc3BsaXQoJyAnKTtcclxuXHJcbiAgICBpZiAoc3BsaXRFeHByZXNzaW9uLmxlbmd0aCA+IE1FQVNVUkVfT0ZfVElNRV9NQVAubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjcm9uIGV4cHJlc3Npb247IGxpbWl0ZWQgdG8gJHtNRUFTVVJFX09GX1RJTUVfTUFQLmxlbmd0aH0gdmFsdWVzLmApO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXRFeHByZXNzaW9uLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgIENyb25WYWxpZGF0b3IudmFsaWRhdGVWYWx1ZShNRUFTVVJFX09GX1RJTUVfTUFQW2ldLCBzcGxpdEV4cHJlc3Npb25baV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogdmFsaWRhdGVzIGFueSBnaXZlbiBtZWFzdXJlT2ZUaW1lIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlXHJcbiAgICogQHBhcmFtIHshU3RyaW5nfSBtZWFzdXJlT2ZUaW1lIC0gYXMgZXhwZWN0ZWRcclxuICAgKiBAcGFyYW0geyFTdHJpbmd9IHZhbHVlIC0gdGhlIGNyb24taXNoIGludGVydmFsIHNwZWNpZmllclxyXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBtZWFzdXJlT2ZUaW1lIGlzIGJvZ3VzXHJcbiAgICogQHRocm93cyB7RXJyb3J9IGlmIHZhbHVlIGNvbnRhaW5zIGFuIHVuc3VwcG9ydGVkIGNoYXJhY3RlclxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgdmFsaWRhdGVWYWx1ZShtZWFzdXJlT2ZUaW1lOiBrZXlvZiBFeHByZXNzaW9uLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBjb25zdCB2YWxpZGF0b3JPYmogPSB7XHJcbiAgICAgIG1pbnV0ZTogeyBtaW46IDAsIG1heDogNTkgfSxcclxuICAgICAgaG91cjogeyBtaW46IDAsIG1heDogMjMgfSxcclxuICAgICAgZGF5T2ZUaGVNb250aDogeyBtaW46IDEsIG1heDogMzEgfSxcclxuICAgICAgbW9udGg6IHsgbWluOiAxLCBtYXg6IDEyIH0sXHJcbiAgICAgIGRheU9mVGhlV2VlazogeyBtaW46IDAsIG1heDogNyB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHZhbGlkQ2hhcnMgPSAvXlswLTkqLV0vO1xyXG5cclxuICAgIGlmICghdmFsaWRhdG9yT2JqW21lYXN1cmVPZlRpbWVdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZWFzdXJlT2ZUaW1lOyBWYWxpZCBvcHRpb25zIGFyZTogJHtNRUFTVVJFX09GX1RJTUVfTUFQLmpvaW4oJywgJyl9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF2YWxpZENoYXJzLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZTsgT25seSBudW1iZXJzIDAtOSwgXCItXCIsIGFuZCBcIipcIiBjaGFycyBhcmUgYWxsb3dlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gJyonKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayB0byBzZWUgaWYgdmFsdWUgaXMgd2l0aGluIHJhbmdlIGlmIHZhbHVlIGlzIG5vdCAnKidcclxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCctJykgPj0gMCkge1xyXG4gICAgICAvLyB2YWx1ZSBpcyBhIHJhbmdlIGFuZCBtdXN0IGJlIHNwbGl0IGludG8gaGlnaCBhbmQgbG93XHJcbiAgICAgIGNvbnN0IHJhbmdlQXJyYXk6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgdW5kZWZpbmVkPiA9IHZhbHVlXHJcbiAgICAgICAgLnNwbGl0KCctJylcclxuICAgICAgICAubWFwKChyYW5nZSkgPT4gcGFyc2VJbnQocmFuZ2UsIDEwKSlcclxuICAgICAgICAuZmlsdGVyKChyYW5nZSkgPT4gaXNOYU4ocmFuZ2UpID09PSBmYWxzZSk7XHJcblxyXG4gICAgICBjb25zdCBbcmFuZ2VNaW4sIHJhbmdlTWF4XSA9IHJhbmdlQXJyYXk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIHJhbmdlTWluICE9PSBcIm51bWJlclwiIHx8IHJhbmdlTWluIDwgdmFsaWRhdG9yT2JqW21lYXN1cmVPZlRpbWVdLm1pbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZTsgYm90dG9tIG9mIHJhbmdlIGlzIG5vdCB2YWxpZCBmb3IgXFxcXFwiJHttZWFzdXJlT2ZUaW1lfVxcXFxcIi4gTGltaXQgaXMgJHt2YWxpZGF0b3JPYmpbbWVhc3VyZU9mVGltZV0ubWlufS5gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiByYW5nZU1heCAhPT0gXCJudW1iZXJcIiB8fCByYW5nZU1heCA+IHZhbGlkYXRvck9ialttZWFzdXJlT2ZUaW1lXS5tYXgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWU7IHRvcCBvZiByYW5nZSBpcyBub3QgdmFsaWQgZm9yIFxcXFxcIiR7bWVhc3VyZU9mVGltZX1cXFxcXCIuIExpbWl0IGlzICR7dmFsaWRhdG9yT2JqW21lYXN1cmVPZlRpbWVdLm1heH0uYCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChwYXJzZUludCh2YWx1ZSkgPCB2YWxpZGF0b3JPYmpbbWVhc3VyZU9mVGltZV0ubWluKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlOyBnaXZlbiB2YWx1ZSBpcyBub3QgdmFsaWQgZm9yIFxcXFxcIiR7bWVhc3VyZU9mVGltZX1cXFxcXCIuIE1pbmltdW0gdmFsdWUgaXMgXFxcXFwiJHt2YWxpZGF0b3JPYmpbbWVhc3VyZU9mVGltZV0ubWlufVxcXFxcIi5gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhcnNlSW50KHZhbHVlKSA+IHZhbGlkYXRvck9ialttZWFzdXJlT2ZUaW1lXS5tYXgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWU7IGdpdmVuIHZhbHVlIGlzIG5vdCB2YWxpZCBmb3IgXFxcXFwiJHttZWFzdXJlT2ZUaW1lfVxcXFxcIi4gTWF4aW11bSB2YWx1ZSBpcyBcXFxcXCIke3ZhbGlkYXRvck9ialttZWFzdXJlT2ZUaW1lXS5tYXh9XFxcXFwiLmApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==