import { __read, __values } from 'tslib';
import * as Cron from 'cron-converter';

var MINUTE = "minute";
var HOUR = "hour";
var DAY_OF_THE_MONTH = "dayOfTheMonth";
var MONTH = "month";
var DAY_OF_THE_WEEK = "dayOfTheWeek";
var DEFAULT_INTERVAL = ['*'];
/**
 * Contains the position-to-name mapping of the cron expression
 * @type {Array}
 * @const
 */
var MEASURE_OF_TIME_MAP = [
    MINUTE,
    HOUR,
    DAY_OF_THE_MONTH,
    MONTH,
    DAY_OF_THE_WEEK,
];

// https://github.com/microsoft/TypeScript/pull/12253#issuecomment-353494273
function keys(object) {
    return Object.keys(object);
}

var CronValidator = /** @class */ (function () {
    function CronValidator() {
    }
    /**
     * validates a given cron expression (object) for length, then calls validateValue on each value
     * @param {!{
     *  minute: Array.string,
     *  hour: Array.string,
     *  dayOfTheMonth: Array.string,
     *  month: Array.string,
     *  dayOfTheWeek: Array.string,
     * }} expression - rich object containing the state of the cron expression
     * @throws {Error} if expression contains more than 5 keys
     */
    CronValidator.validateExpression = function (expression) {
        // don't care if it's less than 5, we'll just set those to the default '*'
        if (keys(expression).length > MEASURE_OF_TIME_MAP.length) {
            throw new Error("Invalid cron expression; limited to " + MEASURE_OF_TIME_MAP.length + " values.");
        }
        keys(expression).forEach(function (key) {
            expression[key].forEach(function (value) {
                CronValidator.validateValue(key, value);
            });
        });
    };
    /**
     * validates a given cron expression (string) for length, then calls validateValue on each value
     * @param {!String} expression - an optionally empty string containing at most 5 space delimited expressions.
     * @throws {Error} if the string contains more than 5 space delimited parts.
     */
    CronValidator.validateString = function (expression) {
        var splitExpression = expression.split(' ');
        if (splitExpression.length > MEASURE_OF_TIME_MAP.length) {
            throw new Error("Invalid cron expression; limited to " + MEASURE_OF_TIME_MAP.length + " values.");
        }
        for (var i = 0; i < splitExpression.length; i += 1) {
            CronValidator.validateValue(MEASURE_OF_TIME_MAP[i], splitExpression[i]);
        }
    };
    /**
     * validates any given measureOfTime and corresponding value
     * @param {!String} measureOfTime - as expected
     * @param {!String} value - the cron-ish interval specifier
     * @throws {Error} if measureOfTime is bogus
     * @throws {Error} if value contains an unsupported character
     */
    CronValidator.validateValue = function (measureOfTime, value) {
        var validatorObj = {
            minute: { min: 0, max: 59 },
            hour: { min: 0, max: 23 },
            dayOfTheMonth: { min: 1, max: 31 },
            month: { min: 1, max: 12 },
            dayOfTheWeek: { min: 0, max: 7 }
        };
        var validChars = /^[0-9*-]/;
        if (!validatorObj[measureOfTime]) {
            throw new Error("Invalid measureOfTime; Valid options are: " + MEASURE_OF_TIME_MAP.join(', '));
        }
        if (!validChars.test(value)) {
            throw new Error('Invalid value; Only numbers 0-9, "-", and "*" chars are allowed');
        }
        if (value === '*') {
            return;
        }
        // check to see if value is within range if value is not '*'
        if (value.indexOf('-') >= 0) {
            // value is a range and must be split into high and low
            var rangeArray = value
                .split('-')
                .map(function (range) { return parseInt(range, 10); })
                .filter(function (range) { return isNaN(range) === false; });
            var _a = __read(rangeArray, 2), rangeMin = _a[0], rangeMax = _a[1];
            if (typeof rangeMin !== "number" || rangeMin < validatorObj[measureOfTime].min) {
                throw new Error("Invalid value; bottom of range is not valid for \\\"" + measureOfTime + "\\\". Limit is " + validatorObj[measureOfTime].min + ".");
            }
            if (typeof rangeMax !== "number" || rangeMax > validatorObj[measureOfTime].max) {
                throw new Error("Invalid value; top of range is not valid for \\\"" + measureOfTime + "\\\". Limit is " + validatorObj[measureOfTime].max + ".");
            }
        }
        else {
            if (parseInt(value) < validatorObj[measureOfTime].min) {
                throw new Error("Invalid value; given value is not valid for \\\"" + measureOfTime + "\\\". Minimum value is \\\"" + validatorObj[measureOfTime].min + "\\\".");
            }
            if (parseInt(value) > validatorObj[measureOfTime].max) {
                throw new Error("Invalid value; given value is not valid for \\\"" + measureOfTime + "\\\". Maximum value is \\\"" + validatorObj[measureOfTime].max + "\\\".");
            }
        }
    };
    return CronValidator;
}());

/**
 * Initializes a CronBuilder with an optional initial cron expression.
 * @param {String=} initialExpression - if provided, it must be up to 5 space delimited parts
 * @throws {Error} if the initialExpression is bogus
 * @constructor
 */
var CronBuilder = /** @class */ (function () {
    function CronBuilder(initialExpression) {
        if (initialExpression === void 0) { initialExpression = "* * * * *"; }
        if (initialExpression) {
            CronValidator.validateString(initialExpression);
            var splitExpression = initialExpression.split(' ');
            this.expression = {
                minute: splitExpression[0] ? splitExpression[0].split(",") : DEFAULT_INTERVAL,
                hour: splitExpression[1] ? splitExpression[1].split(",") : DEFAULT_INTERVAL,
                dayOfTheMonth: splitExpression[2] ? splitExpression[2].split(",") : DEFAULT_INTERVAL,
                month: splitExpression[3] ? splitExpression[3].split(",") : DEFAULT_INTERVAL,
                dayOfTheWeek: splitExpression[4] ? splitExpression[4].split(",") : DEFAULT_INTERVAL,
            };
        }
        else {
            this.expression = {
                minute: DEFAULT_INTERVAL,
                hour: DEFAULT_INTERVAL,
                dayOfTheMonth: DEFAULT_INTERVAL,
                month: DEFAULT_INTERVAL,
                dayOfTheWeek: DEFAULT_INTERVAL,
            };
        }
    }
    /**
     * builds a working cron expression based on the state of the cron object
     * @param {!Object} [options] - customize how to build cron string
     * @param {!Boolean} [options.plain=true] - get cron string as it is, otherwise build short cron string.
     * if false: * 13 * 1-6 0,1,2,3,5,6 ---> * 13 * 1-6 0-3,5-6
     * @param {!Boolean} [options.outputWeekdayNames=false] - changes the numbers to 3 letter weekday names.
     * if true: *\/5 9-17/2 * 1-3 1-5 ---> *\/5 *(10-16)/2 * JAN-MAR MON-FRI
     * @param {!Boolean} [options.outputMonthNames=false] - changes the numbers to 3 letter month names.
     * if true: *\/5 9-17/2 * 1-3 1-5 ---> *\/5 *(10-16)/2 * JAN-MAR MON-FRI
     * @param {!Boolean} [options.outputHashes=false] - changes the * to H.
     * if true: *\/5 9-17/2 * 1-3 1-5 ---> H/5 H(10-16)/2 H 1-3 1-5
     * @returns {string} - working cron expression
     */
    CronBuilder.prototype.build = function (options) {
        var plain = (options !== null && options !== void 0 ? options : { plain: true }).plain;
        var cronString = [
            this.expression.minute.join(','),
            this.expression.hour.join(','),
            this.expression.dayOfTheMonth.join(','),
            this.expression.month.join(','),
            this.expression.dayOfTheWeek.join(','),
        ].join(' ');
        if (plain) {
            return cronString;
        }
        var cronInstance = new Cron(options);
        cronInstance.fromString(cronString);
        return cronInstance.toString();
    };
    /**
     * adds a value to what exists currently (builds)
     * @param {!String} measureOfTime
     * @param {!String} value
     * @throws {Error} if measureOfTime or value fail validation
     */
    CronBuilder.prototype.addValue = function (measureOfTime, value) {
        CronValidator.validateValue(measureOfTime, value);
        if (this.expression[measureOfTime].length === 1 && this.expression[measureOfTime][0] === '*') {
            this.expression[measureOfTime] = [value];
        }
        else {
            if (this.expression[measureOfTime].indexOf(value) < 0) {
                this.expression[measureOfTime].push(value);
            }
        }
    };
    ;
    /**
     * removes a single explicit value (subtracts)
     * @param {!String} measureOfTime - as you might guess
     * @param {!String} value - the offensive value
     * @throws {Error} if measureOfTime is bogus.
     */
    CronBuilder.prototype.removeValue = function (measureOfTime, value) {
        if (!this.expression[measureOfTime]) {
            throw new Error("Invalid measureOfTime: Valid options are: " + MEASURE_OF_TIME_MAP.join(', '));
        }
        if (this.expression[measureOfTime].length === 1 && this.expression[measureOfTime][0] === '*') {
            console.log('The value for "' + measureOfTime + '" is already at the default value of "*" - this is a no-op.');
            return;
        }
        this.expression[measureOfTime] = this.expression[measureOfTime].filter(function (timeValue) {
            return value !== timeValue;
        });
        if (!this.expression[measureOfTime].length) {
            this.expression[measureOfTime] = DEFAULT_INTERVAL;
        }
    };
    ;
    CronBuilder.prototype.get = function (measureOfTime, options) {
        if (!this.expression[measureOfTime]) {
            throw new Error("Invalid measureOfTime: Valid options are: " + MEASURE_OF_TIME_MAP.join(', '));
        }
        var expand = (options !== null && options !== void 0 ? options : { expand: false }).expand;
        if (!expand) {
            return this.expression[measureOfTime].join(',');
        }
        var expression = this.getAll({ expand: expand });
        return expression[measureOfTime];
    };
    CronBuilder.prototype.getAll = function (options) {
        var expand = (options !== null && options !== void 0 ? options : { expand: false }).expand;
        if (!expand) {
            return this.expression;
        }
        var cronString = this.build({ plain: true });
        var cronInstance = new Cron();
        cronInstance.fromString(cronString);
        var cronArray = cronInstance.toArray();
        return {
            minute: cronArray[0],
            hour: cronArray[1],
            dayOfTheMonth: cronArray[2],
            month: cronArray[3],
            dayOfTheWeek: cronArray[4],
        };
    };
    /**
     * sets the state of a given measureOfTime
     * @param {!String} measureOfTime - yup
     * @param {!Array.<String>} value - the 5 tuple array of values to set
     * @returns {!String} the comma separated version of the value that you passed in
     * @throws {Error} if your "value" is not an Array&lt;String&gt;
     * @throws {Error} when any item in your value isn't a legal cron-ish descriptor
     */
    CronBuilder.prototype.set = function (measureOfTime, value) {
        var e_1, _a;
        if (!Array.isArray(value)) {
            throw new Error('Invalid value; Value must be in the form of an Array.');
        }
        try {
            for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                var item = value_1_1.value;
                CronValidator.validateValue(measureOfTime, item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.expression[measureOfTime] = value;
        return this.expression[measureOfTime].join(',');
    };
    /**
     * sets the state for the entire cron expression
     * @param {!{
     *  minute: Array.string,
     *  hour: Array.string,
     *  dayOfTheMonth: Array.string,
     *  month: Array.string,
     *  dayOfTheWeek: Array.string,
     * }} expToSet - the entirety of the cron expression.
     * @throws {Error} as usual
     */
    CronBuilder.prototype.setAll = function (expToSet) {
        var _this = this;
        CronValidator.validateExpression(expToSet);
        keys(this.expression).forEach(function (key) { return _this.expression[key] = expToSet[key]; });
    };
    return CronBuilder;
}());

/*
 * Public API Surface of cron-builder-ts
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CronBuilder, CronValidator, DAY_OF_THE_MONTH, DAY_OF_THE_WEEK, DEFAULT_INTERVAL, HOUR, MEASURE_OF_TIME_MAP, MINUTE, MONTH };
//# sourceMappingURL=cron-builder-ts.js.map
